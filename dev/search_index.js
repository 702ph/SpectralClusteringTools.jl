var documenterSearchIndex = {"docs":
[{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"CurrentModule = SpectralClusteringTools","category":"page"},{"location":"advanced-guide/#Spectral-Clustering:-Advanced-Guide","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"","category":"section"},{"location":"advanced-guide/#1.-Introduction","page":"Spectral Clustering: Advanced Guide","title":"1. Introduction","text":"","category":"section"},{"location":"advanced-guide/#1.1-What-is-Spectral-Clustering?","page":"Spectral Clustering: Advanced Guide","title":"1.1 What is Spectral Clustering?","text":"","category":"section"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"Spectral Clustering is a clustering method that utilizes eigenvalue decomposition of graphs to identify clusters in data. Unlike traditional clustering algorithms such as k-means, Spectral Clustering can capture nonlinear structures in the data.","category":"page"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"The paper \"A Tutorial on Spectral Clustering\" provides a comprehensive theoretical foundation for Spectral Clustering, outlining the process as follows:","category":"page"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"Construct a similarity graph\nCompute the graph Laplacian\nPerform eigenvalue decomposition\nEmbed data into a lower-dimensional space\nApply clustering (typically using k-means)","category":"page"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"This tutorial will provide a guide on how to implement Spectral Clustering.","category":"page"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"Reference Papers:","category":"page"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"A Tutorial on Spectral Clustering\nSelf-Tuning Spectral Clustering","category":"page"},{"location":"advanced-guide/#2.-Parameter-Settings-(Parameter-Types)","page":"Spectral Clustering: Advanced Guide","title":"2. Parameter Settings (Parameter Types)","text":"","category":"section"},{"location":"advanced-guide/#2.1-SpectralClusteringParams","page":"Spectral Clustering: Advanced Guide","title":"2.1 SpectralClusteringParams","text":"","category":"section"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"Overview: Defines the parameters for similarity graphs used in Spectral Clustering.","category":"page"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"struct SpectralClusteringParams\n    graph_type::Symbol  # :epsilon, :knn, :fully_connected\n    k::Int  # Number of neighbors for k-NN graph\n    ε::Float64  # Threshold for ε-neighborhood graph\n    σ::Float64  # Scale for Gaussian similarity\nend","category":"page"},{"location":"advanced-guide/#2.2-SelfTuningParams","page":"Spectral Clustering: Advanced Guide","title":"2.2 SelfTuningParams","text":"","category":"section"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"Overview: Defines parameters for Self-Tuning Spectral Clustering.","category":"page"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"struct SelfTuningParams\n    k::Int  # Number of nearest neighbors\n    σ::Float64  # Scale for Gaussian kernel\nend","category":"page"},{"location":"advanced-guide/#2.3-NormalizedCutsParams","page":"Spectral Clustering: Advanced Guide","title":"2.3 NormalizedCutsParams","text":"","category":"section"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"Overview: Defines parameters for the Normalized Cuts algorithm.","category":"page"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"struct NormalizedCutsParams\n    σ_spatial::Float64  # Spatial scale\n    σ_feature::Float64  # Feature scale\n    min_ncut::Float64  # Threshold for recursive splitting\n    max_depth::Int  # Maximum recursion depth\n    k_nearest::Int  # Number of nearest neighbors\nend","category":"page"},{"location":"advanced-guide/#3.-Constructing-a-Similarity-Graph","page":"Spectral Clustering: Advanced Guide","title":"3. Constructing a Similarity Graph","text":"","category":"section"},{"location":"advanced-guide/#3.1-Types-of-Similarity-Graphs","page":"Spectral Clustering: Advanced Guide","title":"3.1 Types of Similarity Graphs","text":"","category":"section"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"Graph Type Description Function\nε-neighborhood Graph Connects points within distance ε epsilon_neighborhood_graph\nk-NN Graph Connects each point to k neighbors knn_graph\nMutual k-NN Graph Connects only mutual k-neighbors mutual_knn_graph\nFully Connected Graph Connects all points (weighted) fully_connected_graph","category":"page"},{"location":"advanced-guide/#4.-Implementation-of-Spectral-Clustering","page":"Spectral Clustering: Advanced Guide","title":"4. Implementation of Spectral Clustering","text":"","category":"section"},{"location":"advanced-guide/#4.1-Computing-the-Graph-Laplacian","page":"Spectral Clustering: Advanced Guide","title":"4.1 Computing the Graph Laplacian","text":"","category":"section"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"Lsym = compute_normalized_laplacian(W)","category":"page"},{"location":"advanced-guide/#4.2-Eigenvalue-Decomposition","page":"Spectral Clustering: Advanced Guide","title":"4.2 Eigenvalue Decomposition","text":"","category":"section"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"eigen_decomp = eigen(Symmetric(Lsym))\nU = eigen_decomp.vectors[:, 1:k]","category":"page"},{"location":"advanced-guide/#4.3-Clustering-using-k-means","page":"Spectral Clustering: Advanced Guide","title":"4.3 Clustering using k-means","text":"","category":"section"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"using Clustering\nresult = kmeans(U', 3, init=:kmpp)\nclusters = result.assignments","category":"page"},{"location":"advanced-guide/#5.-Self-Tuning-Spectral-Clustering","page":"Spectral Clustering: Advanced Guide","title":"5. Self-Tuning Spectral Clustering","text":"","category":"section"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"W_self_tuning = construct_self_tuning_affinity(X, SelfTuningParams(3, 1.0))\nclusters_self = self_tuning_spectral_clustering(W_self_tuning, 3)","category":"page"},{"location":"advanced-guide/#6.-Image-Segmentation-using-Normalized-Cuts","page":"Spectral Clustering: Advanced Guide","title":"6. Image Segmentation using Normalized Cuts","text":"","category":"section"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"params = NormalizedCutsParams(σ_spatial=10.0, σ_feature=0.1)\nW_image = compute_image_affinity(spatial_coords, features, params)\nncut_value = compute_ncut_value(W_image, partition)\nsegments = recursive_ncut(W_image, params)\nsegments, W_final = normalized_cuts_segmentation(spatial_coords, features, params)","category":"page"},{"location":"advanced-guide/#7.-Conclusion","page":"Spectral Clustering: Advanced Guide","title":"7. Conclusion","text":"","category":"section"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"This tutorial has provided an overview of the theory behind Spectral Clustering and its implementation in Julia.","category":"page"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"Task Function\nConstruct Similarity Graph construct_similarity_graph\nk-NN Graph knn_graph\nMutual k-NN Graph mutual_knn_graph\nFully Connected Graph fully_connected_graph\nCompute Normalized Laplacian compute_normalized_laplacian\nSpectral Clustering spectral_clustering\nSelf-Tuning Clustering self_tuning_spectral_clustering\nImage Segmentation normalized_cuts_segmentation","category":"page"},{"location":"advanced-guide/","page":"Spectral Clustering: Advanced Guide","title":"Spectral Clustering: Advanced Guide","text":"Use this guide to explore advanced clustering techniques and image segmentation research.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SpectralClusteringTools","category":"page"},{"location":"#SpectralClusteringTools","page":"Home","title":"SpectralClusteringTools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for Spectral Clustering.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for creating test data and providing functions to facilitate clustering analysis.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Advanced Guide","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SpectralClusteringTools's interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SpectralClusteringTools]","category":"page"},{"location":"#SpectralClusteringTools.SpectralClusteringTools","page":"Home","title":"SpectralClusteringTools.SpectralClusteringTools","text":"SpectralClusteringTools.jl Main module file for spectral clustering implementations\n\n\n\n\n\n","category":"module"},{"location":"#SpectralClusteringTools.NormalizedCutsParams","page":"Home","title":"SpectralClusteringTools.NormalizedCutsParams","text":"NormalizedCutsParams\n\nParameters structure for Normalized Cuts algorithm.\n\nFields\n\nσ_spatial::Float64: Spatial scaling parameter for distance calculation\nσ_feature::Float64: Feature scaling parameter for similarity calculation\nmin_ncut::Float64: Threshold for recursive partitioning (default: 0.1)\nmax_depth::Int: Maximum recursion depth (default: 10)\nk_nearest::Int: Number of nearest neighbors for sparse affinity matrix\n\n\n\n\n\n","category":"type"},{"location":"#SpectralClusteringTools.SelfTuningParams","page":"Home","title":"SpectralClusteringTools.SelfTuningParams","text":"v_0.001 Parameters for Self-Tuning Spectral Clustering\n\n\n\n\n\n","category":"type"},{"location":"#SpectralClusteringTools.SpectralClusteringParams","page":"Home","title":"SpectralClusteringTools.SpectralClusteringParams","text":"struct SpectralClusteringParams\n\n    A structure for defining parameters for Spectral Clustering.\n\nFields\n\ngraph_type::Symbol : The method used to construct the similarity graph (:epsilon, :knn, :fully_connected)\nk::Int : Number of nearest neighbors (used when :knn is selected)\nε::Float64 : Epsilon neighborhood (used when :epsilon is selected)\nσ::Float64 : Parameter for the Gaussian similarity function\n\nMethods for constructing the similarity graph\n\n:epsilon - ε-neighborhood graph\n:knn - k-nearest neighbor graph\n:fully_connected - Fully connected graph\n\nReference: \"A Tutorial on Spectral Clustering\" (P7)\n\n\n\n\n\n","category":"type"},{"location":"#SpectralClusteringTools.analyze_eigengaps-Tuple{Matrix{Float64}, Int64}","page":"Home","title":"SpectralClusteringTools.analyze_eigengaps","text":"analyzeeigengaps(L::Matrix{Float64}, maxC::Int)\n\nAnalyze the eigengaps to determine the optimal number of clusters and the corresponding eigenvectors.\n\nThis function is based on the theory that:\n\nFor the ideal case, the eigenvalue 1 should be repeated C times (where C is the number of clusters)\nThere should be a significant gap between the C-th and (C+1)-th eigenvalues\nThe first C eigenvectors should correspond to cluster indicator vectors\n\nParameters:\n\nL::Matrix{Float64}: The normalized Laplacian matrix.\nmax_C::Int: The maximum number of clusters to consider.\n\nReturns:\n\nZ::Matrix{Float64}: The matrix of selected eigenvectors (before rotation).\nbest_C::Int: The optimal number of clusters.\nanalysis_info::Dict: A dictionary containing detailed analysis information, such as the rotation matrix, aligned eigenvectors, and clustering cost.\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.combinations-Tuple{Int64, Int64}","page":"Home","title":"SpectralClusteringTools.combinations","text":"combinations(n::Int, k::Int)\n\nComputes the number of ways to choose k elements from a set of n elements without considering the order.\n\nArguments\n\nn: Total number of elements in the set (Integer).\nk: Number of elements to choose (Integer).\n\nReturns\n\nAn integer representing the number of combinations. If k > n or k < 0, returns 0.\n\nExample\n\n`c = combinations(5, 3)\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.compute_accuracy-Tuple{Vector{Int64}, Vector{Int64}}","page":"Home","title":"SpectralClusteringTools.compute_accuracy","text":"compute_accuracy(y_true::Vector{Int}, y_pred::Vector{Int})\n\nComputes the accuracy of predicted labels compared to true labels.  The accuracy is defined as the proportion of correctly predicted labels to the total number of labels.\n\nArguments\n\ny_true: A vector of true cluster labels.\ny_pred: A vector of predicted cluster labels. Both vectors must have the same length.\n\nReturns\n\nThe accuracy as a Float64 value, representing the fraction of correctly classified instances.\n\nExample\n\naccuracy = compute_accuracy([1, 2, 1], [1, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.compute_ari-Tuple{Vector{Int64}, Vector{Int64}}","page":"Home","title":"SpectralClusteringTools.compute_ari","text":"compute_ari(y_true::Vector{Int}, y_pred::Vector{Int})\n\nComputes the Adjusted Rand Index (ARI) to measure the similarity between two clusterings, accounting for chance. The ARI ranges from -1 to 1, where 1 indicates perfect agreement, 0 indicates random labeling, and negative values suggest disagreement.\n\nArguments\n\ny_true: A vector of true cluster labels.\ny_pred: A vector of predicted cluster labels.  Both vectors must have the same length.\n\nReturns\n\nThe Adjusted Rand Index as a Float64 value.\n\nExample\n\nari = compute_ari([1, 1, 0, 0], [0, 0, 1, 1])\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.compute_image_affinity-Tuple{Matrix{Float64}, Matrix{Float64}, NormalizedCutsParams}","page":"Home","title":"SpectralClusteringTools.compute_image_affinity","text":"compute_image_affinity(spatial_coords::Matrix{Float64}, \n                     features::Matrix{Float64}, \n                     params::NormalizedCutsParams)\n\nConstructs the affinity matrix for image segmentation considering both spatial and feature information.\n\nArguments\n\nspatial_coords::Matrix{Float64}: N×2 matrix of pixel coordinates\nfeatures::Matrix{Float64}: N×D matrix of pixel features (intensity, color, etc.)\nparams::NormalizedCutsParams: Parameters for the algorithm\n\nReturns\n\nW::Matrix{Float64}: N×N sparse affinity matrix\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.compute_ncut_value-Tuple{Matrix{Float64}, Vector{Int64}}","page":"Home","title":"SpectralClusteringTools.compute_ncut_value","text":"compute_ncut_value(W::Matrix{Float64}, partition::Vector{Int})\n\nComputes the normalized cut value for a given partition.\n\nArguments\n\nW::Matrix{Float64}: Affinity matrix\npartition::Vector{Int}: Binary partition vector (1s and 2s)\n\nReturns\n\nncut::Float64: Normalized cut value\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.compute_nmi-Tuple{Vector{Int64}, Vector{Int64}}","page":"Home","title":"SpectralClusteringTools.compute_nmi","text":"compute_nmi(y_true::Vector{Int}, y_pred::Vector{Int})\n\nComputes the Normalized Mutual Information (NMI) between two clusterings to evaluate their similarity.  The NMI ranges from 0 to 1, where 1 indicates perfect agreement and 0 indicates no mutual information.\n\nArguments\n\ny_true: A vector of true cluster labels.\ny_pred: A vector of predicted cluster labels. Both vectors must have the same length.\n\nReturns\n\nThe Normalized Mutual Information as a Float64 value.\n\nExample\n\n`nmi = compute_nmi([1, 1, 0, 0], [0, 0, 1, 1])\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.compute_normalized_laplacian-Tuple{Matrix{Float64}}","page":"Home","title":"SpectralClusteringTools.compute_normalized_laplacian","text":"compute_normalized_laplacian(W::Matrix{Float64})\n\nComputes the normalized Laplacian matrix Lsym using the formula:\n\n``Lsym = D^(−1/2)LD^(−1/2) = I − D^(-1/2) W D^(-1/2)``\n\nwhere D is the degree matrix.\n\nArguments\n\nW: A symmetric adjacency matrix (weight matrix) of the graph.\n\nReturns\n\nThe normalized Laplacian matrix Lsym.\n\nNotes\n\nIf any node has a degree of zero (isolated vertex), small connections are added to ensure numerical stability.\nThe resulting Laplacian matrix is symmetrized and clamped to the range [-1, 1] to maintain stability.\n\nExample\n\nW = [0.0 1.0 0.5; 1.0 0.0 1.0; 0.5 1.0 0.0]\nLsym = compute_normalized_laplacian(W)\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.construct_self_tuning_affinity-Tuple{Matrix{Float64}, SelfTuningParams}","page":"Home","title":"SpectralClusteringTools.construct_self_tuning_affinity","text":"constructselftuningaffinity(X::Matrix{Float64}, params::SelfTuningParams; isspherical::Bool=false)\n\nConstruct the self-tuning affinity matrix A based on the input data matrix X and the provided self-tuning parameters.\n\nThe self-tuning affinity matrix is computed as: Aᵢⱼ = exp(-d²(sᵢ,sⱼ)/(σᵢσⱼ))\n\nwhere d(sᵢ, sⱼ) is the distance between data points sᵢ and sⱼ, and σᵢ and σⱼ are the local scaling parameters computed for each point.\n\nParameters:\n\nX::Matrix{Float64}: The input data matrix.\nparams::SelfTuningParams: A struct containing the self-tuning parameters, including the number of neighbors K for local scaling and whether to use local scaling.\nis_spherical::Bool=false: A flag indicating whether the data is on a spherical manifold (default is false, i.e., planar data).\n\nReturns:\n\nA::Matrix{Float64}: The self-tuning affinity matrix.\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.contingency_matrix-Tuple{Vector{Int64}, Vector{Int64}}","page":"Home","title":"SpectralClusteringTools.contingency_matrix","text":"contingency_matrix(y_true::Vector{Int}, y_pred::Vector{Int})\n\nBuilds a contingency matrix to measure the overlap between two clusterings.  Each entry (i, j) in the matrix represents the number of samples in both true cluster i and predicted cluster j.\n\nArguments\n\ny_true: A vector of true cluster labels.\ny_pred: A vector of predicted cluster labels. Both vectors must have the same length.\n\nReturns\n\nA 2D matrix where rows correspond to true clusters and columns to predicted clusters, containing counts of overlapping elements.\n\nExample\n\n`matrix = contingency_matrix([1, 1, 0, 0], [0, 0, 1, 1])\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.determine_best_C-Tuple{Vector{Float64}, Matrix{Float64}, Int64}","page":"Home","title":"SpectralClusteringTools.determine_best_C","text":"determinebestC(eigvals::Vector{Float64}, eigvecs::Matrix{Float64}, max_C::Int)\n\nDetermine the optimal number of clusters based on the eigenvalues and eigenvectors of the normalized Laplacian matrix.\n\nThis function uses the average cost comparison method to find the number of clusters whose alignment cost is closest to the average cost across all potential cluster counts.\n\nParameters:\n\neigvals::Vector{Float64}: The vector of eigenvalues of the normalized Laplacian matrix.\neigvecs::Matrix{Float64}: The matrix of eigenvectors of the normalized Laplacian matrix.\nmax_C::Int: The maximum number of clusters to consider.\n\nReturns:\n\nbest_C::Int: The optimal number of clusters.\nbest_R::Matrix{Float64}: The rotation matrix that best aligns the eigenvectors for the optimal number of clusters.\nbest_Z::Matrix{Float64}: The input eigenvectors rotated by the optimal rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.epsilon_neighborhood_graph-Tuple{Matrix{Float64}, Float64}","page":"Home","title":"SpectralClusteringTools.epsilon_neighborhood_graph","text":"epsilon_neighborhood_graph(X::Matrix{Float64}, ε::Float64)\n\nConstructs an ε-neighborhood graph, where an edge is formed between two points if their Euclidean distance is less than ε.\n\nArguments\n\nX: A matrix where each column represents a data point in a feature space.\nε: A threshold distance; two points are connected if their Euclidean distance is smaller than ε.\n\nReturns\n\nAn adjacency matrix W of size (n, n), where n is the number of data points.\nW[i, j] = 1.0 if ||X[:, i] - X[:, j]||_2 < ε, otherwise W[i, j] = 0.0.\nThe matrix W is symmetric.\n\nNotes\n\nThe graph is unweighted (binary adjacency matrix).\nThis method is mainly used for comparison, as NJW spectral clustering typically uses a weighted similarity graph.\n\nExample\n\nX = rand(2, 5)  # 2D points (each column is a data point)\nε = 0.5\nW = epsilon_neighborhood_graph(X, ε)\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.fully_connected_graph-Tuple{Matrix{Float64}, Float64}","page":"Home","title":"SpectralClusteringTools.fully_connected_graph","text":"fully_connected_graph(X::Matrix{Float64}, σ::Float64)\n\nConstructs a fully connected graph, where all data points are connected to each other with an edge. The edge weights are determined by a similarity function, such as a Gaussian kernel.\n\nArguments\n\nX: A matrix where each column represents a data point in a feature space.\nσ: A scaling parameter for the Gaussian similarity function.\n\nReturns\n\nAn adjacency matrix W of size (n, n), where n is the number of data points.\nW[i, j] represents the similarity between points i and j, computed as:\nWi j = xpleft(-\fracX_i - X_j^22sigma^2 ight)\nW[i, j] is always positive and symmetric (W[i, j] = W[j, i]).\nLarger values of σ result in more globally connected graphs, while smaller σ emphasizes local neighborhoods.\n\nNotes\n\nAll points are connected: Unlike k-NN or ε-neighborhood graphs, this graph is fully connected.\nEdge weights depend on similarity: The similarity function should naturally model local neighborhoods (e.g., the Gaussian kernel).\nGaussian kernel ensures smooth transitions: The similarity decreases exponentially as the distance increases.\nNo thresholding: Any two points with positive similarity are connected.\n\nExample\n\n    X = rand(2, 10)  # 2D points (each column is a data point)\n    σ = 1.0\n    W = fully_connected_graph(X, σ)\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.generate_mixed_concentric_data-Tuple{}","page":"Home","title":"SpectralClusteringTools.generate_mixed_concentric_data","text":"generatemixedconcentric_data()\n\nGenerate a dataset of mixed concentric circles.\n\nThis function creates a dataset with three main concentric circles, each with two smaller concentric circles mixed in. The data points are generated with a small amount of random noise to make the task more challenging.\n\nReturns:\n\nX::Matrix{Float64}: The matrix of data points, with each column representing a data point.\nlabels::Vector{Int}: The vector of true cluster labels for each data point.\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.generate_mixed_moons_data","page":"Home","title":"SpectralClusteringTools.generate_mixed_moons_data","text":"generate_mixed_moons_data(n_samples=300, noise=0.05)\n\nGenerate two interleaved moon-shaped datasets with overlapping regions. This function is primarily used for creating synthetic data to test clustering algorithms.\n\nArguments\n\nn_samples (Int=300): Number of base samples for each moon shape\nnoise (Float64=0.05): Standard deviation of Gaussian noise added to the data points\n\nReturns\n\nReturns a tuple (X, labels):\n\nX: 2×N matrix where N = 2 * (n_samples + n_samples÷3), each column represents a 2D data point\nlabels: Vector of length N containing class labels (1 or 2) for each point\n\nImplementation Details\n\nGenerates base data points for two moon shapes.\nAdds Gaussian noise to each data point.\nGenerates additional mixing points (n_samples÷3 points) for each class.\nMixing points have higher noise (2x the base noise).\n\nExample\n\nX, labels = generate_mixed_moons_data(500, 0.1)\nscatter(X[1,:], X[2,:], group=labels, title=\"Mixed Moons Dataset\")\n\n\n\n\n\n","category":"function"},{"location":"#SpectralClusteringTools.knn_graph-Tuple{Matrix{Float64}, Int64}","page":"Home","title":"SpectralClusteringTools.knn_graph","text":"knn_graph(X::Matrix{Float64}, k::Int)\n\nConstructs a k-nearest neighbor (k-NN) graph, where each data point is connected to its k nearest neighbors. The graph is undirected, meaning that if vi is among the k nearest neighbors of vj, then vj is also connected to vi.\n\nArguments\n\nX: A matrix where each column represents a data point in a feature space.\nk: The number of nearest neighbors to consider for each data point.\n\nReturns\n\nAn adjacency matrix W of size (n, n), where n is the number of data points.\nIf two points are mutual k-nearest neighbors, an edge is formed.\nW[i, j] represents the similarity between points i and j, computed using a Gaussian similarity function:\nWi j = xpleft(-\fracd_ij^2sigma_i sigma_j\right)\nd_{ij} is the Euclidean distance between points i and j.\nσ_i and σ_j are local scaling parameters based on the k-th nearest neighbor distance.\nThe matrix W is symmetric.\n\nNotes\n\nA KDTree is used for efficient nearest neighbor search.\nThe graph is undirected, meaning that if vi is in the k-nearest neighbors of vj, then an edge is also created from vj to vi.\nLocal scaling is applied using the k-th nearest neighbor distance to prevent numerical instability.\nThe median of the k-th nearest neighbor distances is used to avoid division by very small values.\n\nExample\n\n    using NearestNeighbors  # Ensure NearestNeighbors.jl is installed for KDTree\n    X = rand(2, 10)  # 2D points (each column is a data point)\n    k = 3\n    W = knn_graph(X, k)\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.make_blobs","page":"Home","title":"SpectralClusteringTools.make_blobs","text":"make_blobs(num_classes::Int, num_points_per_class::Int, noise::Float64=0.0)\n\nGenerates a dataset of points distributed on different blobs.  Each blob corresponds to a class.\n\nArguments\n\nnum_classes: Number of spheres (classes) to generate.\nnum_points_per_class: Number of points per class.\nnoise: Maximal noise applied for each point.\n\nReturns\n\nA tuple of (normalized_points, labels), where normalized_points is a matrix of 3D points, and labels indicates class membership.\n\nExample\n\npoints, labels = make_blobs(5, 500, 0.5)\n\n\n\n\n\n","category":"function"},{"location":"#SpectralClusteringTools.make_blobs_2d","page":"Home","title":"SpectralClusteringTools.make_blobs_2d","text":"make_blobs_2d(num_classes::Int, num_points_per_class::Int, noise::Float64=0.0)\n\nGenerates a dataset of points distributed into distinct 2D blobs. Each blob corresponds to a class.\n\nArguments\n\nnum_classes: Number of blobs (classes) to generate.\nnum_points_per_class: Number of points per class.\nnoise: Maximum noise applied to each point.\n\nReturns\n\nA tuple of (points, labels), where points is a matrix of 2D points, and labels indicates class membership.\n\nExample\n\npoints, labels = make_blobs_2d(5, 500, 0.5)\n\n\n\n\n\n","category":"function"},{"location":"#SpectralClusteringTools.make_circles","page":"Home","title":"SpectralClusteringTools.make_circles","text":"make_circles(num_classes::Int, num_points_per_class::Int, noise::Float64=0.0, adjust_scale::Bool=true)\n\nGenerates a dataset of points distributed on concentric circles.  Each circle corresponds to a class, and points are normalized.\n\nArguments\n\nnum_classes: Number of circles (classes) to generate.\nnum_points_per_class: Number of points per class.\nnoise: Maximum noise applied to each point.\nadjust_scale: Adjusts the number of points per circle based on its circumference.\n\nReturns\n\nA tuple of (normalized_points, labels), where normalized_points is a matrix of 2D points, and labels indicates class membership.\n\nExample\n\npoints, labels = make_circles(3, 1000, 0.1, false)\n\n\n\n\n\n","category":"function"},{"location":"#SpectralClusteringTools.make_lines","page":"Home","title":"SpectralClusteringTools.make_lines","text":"make_lines(num_classes::Int, num_points_per_class::Int, noise::Float64=0.0)\n\nGenerates a dataset of points distributed following straight lines. Each line corresponds to a class.\n\nArguments\n\nnum_classes: Number of lines (classes) to generate.\nnum_points_per_class: Number of points per class.\nnoise: Maximal noise applied for each point.\n\nReturns\n\nA tuple of (normalized_points, labels), where normalized_points is a matrix of 3D points, and labels indicates class membership.\n\nExample\n\npoints, labels = make_lines(5, 500, 0.3)\n\n\n\n\n\n","category":"function"},{"location":"#SpectralClusteringTools.make_moons","page":"Home","title":"SpectralClusteringTools.make_moons","text":"make_moons(n_samples::Int=300, noise::Float64=0.05)\n\nGenerate two interleaved moon-shaped datasets with overlapping regions. This function is primarily used for creating synthetic data to test clustering algorithms.\n\nArguments\n\nn_samples (Int=300): Number of base samples for each moon shape\nnoise (Float64=0.05): Standard deviation of Gaussian noise added to the data points\n\nReturns\n\nReturns a tuple (X, labels):\n\nX: 2×N matrix where N = 2 * (n_samples + n_samples÷3), each column represents a 2D data point\nlabels: Vector of length N containing class labels (1 or 2) for each point\n\nImplementation Details\n\nGenerates base data points for two moon shapes.\nAdds Gaussian noise to each data point.\nGenerates additional mixing points (n_samples÷3 points) for each class.\nMixing points have higher noise (2x the base noise).\n\nExample\n\nX, labels = make_moons(500, 0.1)\nscatter(X[1,:], X[2,:], group=labels, title=\"Mixed Moons Dataset\")\n\n\n\n\n\n","category":"function"},{"location":"#SpectralClusteringTools.make_spheres","page":"Home","title":"SpectralClusteringTools.make_spheres","text":"make_spheres(num_classes::Int, num_points_per_class::Int, noise::Float64=0.0, adjust_scale::Bool=true)\n\nGenerates a dataset of points distributed on the surfaces of spheres.  Each sphere corresponds to a class, and points are normalized.\n\nArguments\n\nnum_classes: Number of spheres (classes) to generate.\nnum_points_per_class: Number of points per class.\nnoise: Maximal noise applied for each point.\nadjust_scale: Adjusts the number of points.\n\nReturns\n\nA tuple of (normalized_points, labels), where normalized_points is a matrix of 3D points, and labels indicates class membership.\n\nExample\n\npoints, labels = make_sphere(3, 1000, 0.1, false)\n\n\n\n\n\n","category":"function"},{"location":"#SpectralClusteringTools.make_spirals","page":"Home","title":"SpectralClusteringTools.make_spirals","text":"make_spirals(num_points_per_class::Int, noise::Float64=0.0)\n\nGenerates a dataset of points following 2 interlacing spirals. Each spiral corresponds to a class.\n\nArguments\n\nnum_points_per_class: Number of points per class.\nnoise: Maximal noise applied for each point.\n\nReturns\n\nA tuple of (normalized_points, labels), where normalized_points is a matrix of 3D points, and labels indicates class membership.\n\nExample\n\npoints, labels = make_spirals(500, 1.0)\n\n\n\n\n\n","category":"function"},{"location":"#SpectralClusteringTools.make_spirals_2d","page":"Home","title":"SpectralClusteringTools.make_spirals_2d","text":"make_spirals_2d(num_points_per_class::Int, noise::Float64=0.0)\n\nGenerates a dataset of points forming two interlacing spirals in 2D. Each spiral corresponds to a class.\n\nArguments\n\nnum_points_per_class: Number of points per class.\nnoise: Maximum noise applied to each point.\n\nReturns\n\nA tuple of (points, labels), where points is a matrix of 2D points, and labels indicates class membership.\n\nExample\n\npoints, labels = make_spirals_2d(500, 0.1)\n\n\n\n\n\n","category":"function"},{"location":"#SpectralClusteringTools.mutual_knn_graph-Tuple{Matrix{Float64}, Int64}","page":"Home","title":"SpectralClusteringTools.mutual_knn_graph","text":"mutual_knn_graph(X::Matrix{Float64}, k::Int)\n\nConstructs a mutual k-nearest neighbor (k-NN) graph, where two data points vi and vj are connected only if they are among each other's k nearest neighbors. The edge weights are computed using a Gaussian similarity function with local scaling.\n\nArguments\n\nX: A matrix where each column represents a data point in a feature space.\nk: The number of nearest neighbors to consider for each data point.\n\nReturns\n\nAn adjacency matrix W of size (n, n), where n is the number of data points.\nW[i, j] > 0 only if vi is in the k-nearest neighbors of vj and vj is in the k-nearest neighbors of vi.\nThe edge weight is computed using a Gaussian similarity function with adaptive local scaling:\nWi j = xpleft(-\fracd_ij^2sigma_i sigma_j ight)\nd_{ij} is the Euclidean distance between points i and j.\nσ_i and σ_j are local scaling parameters based on the k-th nearest neighbor distance.\nThe matrix W is symmetric.\n\nNotes\n\nMutual k-NN condition: Unlike standard k-NN graphs, an edge is only formed if vi and vj are in each other's k-nearest neighbor lists.\nLocal scaling: The similarity measure adapts based on the k-th nearest neighbor distance of each point (σ_i and σ_j).\nKDTree is used for efficient nearest neighbor search.\n\nExample\n\njulia     using NearestNeighbors  # Ensure NearestNeighbors.jl is installed for KDTree     X = rand(2, 10)  # 2D points (each column is a data point)     k = 3     W = mutual_knn_graph(X, k)`\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.normalized_cuts_segmentation-Tuple{Matrix{Float64}, Matrix{Float64}, NormalizedCutsParams}","page":"Home","title":"SpectralClusteringTools.normalized_cuts_segmentation","text":"normalized_cuts_segmentation(spatial_coords::Matrix{Float64}, \n                           features::Matrix{Float64}, \n                           params::NormalizedCutsParams)\n\nMain function for normalized cuts image segmentation.\n\nArguments\n\nspatial_coords::Matrix{Float64}: N×2 matrix of pixel coordinates\nfeatures::Matrix{Float64}: N×D matrix of pixel features\nparams::NormalizedCutsParams: Algorithm parameters\n\nReturns\n\nsegments::Vector{Int}: Segment labels for each pixel\nW::Matrix{Float64}: Computed affinity matrix\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.print_efficiency-Tuple{Vector{Int64}, Vector{Int64}}","page":"Home","title":"SpectralClusteringTools.print_efficiency","text":"print_efficiency(y_true::Vector{Int}, y_pred::Vector{Int})\n\nComputes the efficiency metrics for clustering, including Accuracy, Adjusted Rand Index (ARI), and Normalized Mutual Information (NMI). \n\nArguments\n\ny_true: A vector of true cluster labels.\ny_pred: A vector of predicted cluster labels. Both vectors must have the same length.\n\nReturns\n\nA nothing value (prints the efficiency metrics directly).\n\nExample\n\n`print_efficiency([1, 1, 0, 0], [0, 0, 1, 1])\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.recover_rotation-Tuple{Matrix{Float64}}","page":"Home","title":"SpectralClusteringTools.recover_rotation","text":"recoverrotation(X::Matrix{Float64}; maxiter::Int=2000, tol::Float64=1e-6, α::Float64=0.1)\n\nRecover the optimal rotation matrix R that best aligns the columns of the input matrix X with the canonical coordinate system.\n\nThis function uses an incremental gradient descent scheme based on Givens rotations to minimize the cost function and find the optimal rotation matrix.\n\nParameters:\n\nX::Matrix{Float64}: The input matrix of eigenvectors to be aligned.\nmax_iter::Int=2000: The maximum number of iterations for the gradient descent algorithm.\ntol::Float64=1e-6: The tolerance for convergence of the gradient descent algorithm.\nα::Float64=0.1: The learning rate for the gradient descent algorithm.\n\nReturns:\n\nR::Matrix{Float64}: The optimal rotation matrix.\nZ::Matrix{Float64}: The input matrix X rotated by the optimal rotation matrix R.\ncost::Float64: The final cost value of the optimization.\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.recursive_ncut","page":"Home","title":"SpectralClusteringTools.recursive_ncut","text":"recursive_ncut(W::Matrix{Float64}, params::NormalizedCutsParams, depth::Int=0)\n\nRecursively applies normalized cuts to partition the graph.\n\nArguments\n\nW::Matrix{Float64}: Affinity matrix\nparams::NormalizedCutsParams: Algorithm parameters\ndepth::Int: Current recursion depth\n\nReturns\n\npartition::Vector{Int}: Cluster assignments\n\n\n\n\n\n","category":"function"},{"location":"#SpectralClusteringTools.self_tuning_spectral_clustering-Tuple{Matrix{Float64}, Int64, SelfTuningParams}","page":"Home","title":"SpectralClusteringTools.self_tuning_spectral_clustering","text":"selftuningspectralclustering(X::Matrix{Float64}, maxC::Int, params::SelfTuningParams; is_spherical::Bool=false)\n\nPerform self-tuning spectral clustering on the input data matrix X.\n\nThis function implements the full self-tuning spectral clustering algorithm, including the following steps:\n\nConstruct the self-tuning affinity matrix.\nCompute the normalized Laplacian matrix.\nAnalyze the eigengaps to determine the optimal number of clusters.\nRecover the optimal rotation matrix to align the eigenvectors.\nPerform k-means clustering on the rotated eigenvectors.\n\nParameters:\n\nX::Matrix{Float64}: The input data matrix.\nmax_C::Int: The maximum number of clusters to consider.\nparams::SelfTuningParams: A struct containing the self-tuning parameters, including the number of neighbors K for local scaling and whether to use local scaling.\nis_spherical::Bool=false: A flag indicating whether the data is on a spherical manifold (default is false, i.e., planar data).\n\nReturns:\n\nassignments::Vector{Int}: The cluster assignments for each data point.\nbest_C::Int: The optimal number of clusters.\nanalysis_info::Dict: A dictionary containing detailed analysis information, such as the rotation matrix, aligned eigenvectors, and clustering cost.\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.spectral_clustering-Tuple{Matrix{Float64}, Int64, SpectralClusteringParams}","page":"Home","title":"SpectralClusteringTools.spectral_clustering","text":"spectral_clustering(X::Matrix{Float64}, k::Int, params::SpectralClusteringParams)\n\nPerforms spectral clustering on a given dataset using a similarity graph and normalized Laplacian eigenvectors.\n\nArguments\n\nX: A matrix where each column represents a data point in a feature space.\nk: The number of clusters to form.\nparams: A SpectralClusteringParams struct containing parameters for graph construction and similarity computation.\n\nReturns\n\nA vector of cluster assignments, where each index corresponds to a data point in X.\n\nSteps\n\nConstruct the similarity graph W:\nIf params.graph_type == :ε, use an ε-neighborhood graph (epsilon_neighborhood_graph).\nIf params.graph_type == :knn, use a k-nearest neighbor (k-NN) graph (knn_graph).\nIf params.graph_type == :mutual_knn, use a mutual k-NN graph (mutual_knn_graph).\nOtherwise, construct a fully connected graph (fully_connected_graph).\nCompute the normalized Laplacian Lsym:\nLsym = D^(-1/2) * (D - W) * D^(-1/2), where D is the degree matrix.\nCompute the top-k eigenvectors of Lsym:\nSolve for eigenvalues and eigenvectors: eigvals_L, eigvecs_L = eigen(Symmetric(L))\nExtract the k eigenvectors corresponding to the largest k eigenvalues.\nNormalize rows of the eigenvector matrix:\nNormalize each row of U to unit length to obtain T.\nCluster the normalized rows using k-means:\nPerform k-means clustering (kmeans(T', k)) with multiple random initializations.\nSelect the best clustering result based on minimal total cost.\n\nNotes\n\nThe function validates the parameters to ensure k > 0, σ > 0, and k for k-NN > 0.\nIf the similarity matrix W is all zeros, an error is raised.\nUses k-means++ initialization for better clustering stability.\nCatches unexpected errors and logs warnings before throwing an ArgumentError.\n\nExample\n\n    X = rand(2, 100)  # 2D points (each column is a data point)\n    params = SpectralClusteringParams(:knn, k=5, σ=1.0)  # Example params\n    assignments = spectral_clustering(X, 3, params)\n\n\n\n\n\n","category":"method"}]
}
