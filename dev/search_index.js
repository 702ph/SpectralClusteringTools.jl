var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SpectralClusteringTools","category":"page"},{"location":"#SpectralClusteringTools","page":"Home","title":"SpectralClusteringTools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools for Spectral Clustering.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for creating test data and providing functions to facilitate clustering analysis.","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SpectralClusteringTools's interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SpectralClusteringTools]","category":"page"},{"location":"#SpectralClusteringTools.SpectralClusteringTools","page":"Home","title":"SpectralClusteringTools.SpectralClusteringTools","text":"SpectralClusteringTools.jl Main module file for spectral clustering implementations\n\n\n\n\n\n","category":"module"},{"location":"#SpectralClusteringTools.SelfTuningParams","page":"Home","title":"SpectralClusteringTools.SelfTuningParams","text":"v_0.001 Parameters for Self-Tuning Spectral Clustering\n\n\n\n\n\n","category":"type"},{"location":"#SpectralClusteringTools.SpectralClusteringParams","page":"Home","title":"SpectralClusteringTools.SpectralClusteringParams","text":"Construct a similarity graph. W: weighted adjacency matrix(A Tutorial on Spectral Clustering P7)\n\n● According to the reference, there are three ways to do it:     (1) The ε-neighborhood graph     (2) k-nearest neighbor graphs     (3) The fully connected graph ● Parameters for Spectral clustering\n\n\n\n\n\n","category":"type"},{"location":"#SpectralClusteringTools.analyze_eigengaps-Tuple{Matrix{Float64}, Int64}","page":"Home","title":"SpectralClusteringTools.analyze_eigengaps","text":"analyzeeigengaps(L::Matrix{Float64}, maxC::Int)\n\nAnalyze the eigengaps to determine the optimal number of clusters and the corresponding eigenvectors.\n\nThis function is based on the theory that:\n\nFor the ideal case, the eigenvalue 1 should be repeated C times (where C is the number of clusters)\nThere should be a significant gap between the C-th and (C+1)-th eigenvalues\nThe first C eigenvectors should correspond to cluster indicator vectors\n\nParameters:\n\nL::Matrix{Float64}: The normalized Laplacian matrix.\nmax_C::Int: The maximum number of clusters to consider.\n\nReturns:\n\nZ::Matrix{Float64}: The matrix of selected eigenvectors (before rotation).\nbest_C::Int: The optimal number of clusters.\nanalysis_info::Dict: A dictionary containing detailed analysis information, such as the rotation matrix, aligned eigenvectors, and clustering cost.\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.apply_givens_rotation!-Tuple{Matrix{Float64}, SpectralClusteringTools.GivensRotation}","page":"Home","title":"SpectralClusteringTools.apply_givens_rotation!","text":"applygivensrotation!(X::Matrix{Float64}, G::GivensRotation)\n\nApply a Givens rotation to the input matrix X.\n\nA Givens rotation is a plane rotation that operates on a pair of columns in a matrix. This function updates the matrix X in-place by applying the specified Givens rotation.\n\nParameters:\n\nX::Matrix{Float64}: The input matrix to be rotated.\nG::GivensRotation: A struct containing the parameters of the Givens rotation to be applied, including the row indices i and j, and the rotation angle θ.\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.compute_local_scaling-Tuple{Matrix{Float64}, Int64}","page":"Home","title":"SpectralClusteringTools.compute_local_scaling","text":"computelocalscaling(X::Matrix{Float64}, K::Int)\n\nCompute the local scaling parameters σᵢ for each point in the input matrix X.\n\nThe local scaling parameter σᵢ is defined as the distance from point sᵢ to its Kth nearest neighbor.\n\nParameters:\n\nX::Matrix{Float64}: The input data matrix.\nK::Int: The number of nearest neighbors to consider for the local scaling computation.\n\nReturns:\n\nσ::Vector{Float64}: The vector of local scaling parameters, one for each data point.\nanalysis_info::Dict: A dictionary containing additional information used in the local scaling computation, such as the KD-tree, distances to neighbors, and neighbor indices.\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.construct_self_tuning_affinity-Tuple{Matrix{Float64}, SelfTuningParams}","page":"Home","title":"SpectralClusteringTools.construct_self_tuning_affinity","text":"constructselftuningaffinity(X::Matrix{Float64}, params::SelfTuningParams; isspherical::Bool=false)\n\nConstruct the self-tuning affinity matrix A based on the input data matrix X and the provided self-tuning parameters.\n\nThe self-tuning affinity matrix is computed as: Aᵢⱼ = exp(-d²(sᵢ,sⱼ)/(σᵢσⱼ))\n\nwhere d(sᵢ, sⱼ) is the distance between data points sᵢ and sⱼ, and σᵢ and σⱼ are the local scaling parameters computed for each point.\n\nParameters:\n\nX::Matrix{Float64}: The input data matrix.\nparams::SelfTuningParams: A struct containing the self-tuning parameters, including the number of neighbors K for local scaling and whether to use local scaling.\nis_spherical::Bool=false: A flag indicating whether the data is on a spherical manifold (default is false, i.e., planar data).\n\nReturns:\n\nA::Matrix{Float64}: The self-tuning affinity matrix.\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.determine_best_C-Tuple{Vector{Float64}, Matrix{Float64}, Int64}","page":"Home","title":"SpectralClusteringTools.determine_best_C","text":"determinebestC(eigvals::Vector{Float64}, eigvecs::Matrix{Float64}, max_C::Int)\n\nDetermine the optimal number of clusters based on the eigenvalues and eigenvectors of the normalized Laplacian matrix.\n\nThis function uses the average cost comparison method to find the number of clusters whose alignment cost is closest to the average cost across all potential cluster counts.\n\nParameters:\n\neigvals::Vector{Float64}: The vector of eigenvalues of the normalized Laplacian matrix.\neigvecs::Matrix{Float64}: The matrix of eigenvectors of the normalized Laplacian matrix.\nmax_C::Int: The maximum number of clusters to consider.\n\nReturns:\n\nbest_C::Int: The optimal number of clusters.\nbest_R::Matrix{Float64}: The rotation matrix that best aligns the eigenvectors for the optimal number of clusters.\nbest_Z::Matrix{Float64}: The input eigenvectors rotated by the optimal rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.fully_connected_graph-Tuple{Matrix{Float64}, Float64}","page":"Home","title":"SpectralClusteringTools.fully_connected_graph","text":"● Construct fully connected graph ● Connect all points with positive similarity with each other ● Weight all edge by sij ● Only useful if the similarity function itself models local neighbors， example: Gaussian\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.generate_mixed_concentric_data-Tuple{}","page":"Home","title":"SpectralClusteringTools.generate_mixed_concentric_data","text":"generatemixedconcentric_data()\n\nGenerate a dataset of mixed concentric circles.\n\nThis function creates a dataset with three main concentric circles, each with two smaller concentric circles mixed in. The data points are generated with a small amount of random noise to make the task more challenging.\n\nReturns:\n\nX::Matrix{Float64}: The matrix of data points, with each column representing a data point.\nlabels::Vector{Int}: The vector of true cluster labels for each data point.\n\n\n\n\n\n","category":"method"},{"location":"#SpectralClusteringTools.make_blobs","page":"Home","title":"SpectralClusteringTools.make_blobs","text":"make_blobs(num_classes::Int, num_points_per_class::Int, noise::Float64=0.0)\n\nGenerates a dataset of points distributed on different blobs.  Each blob corresponds to a class.\n\nArguments\n\nnum_classes: Number of spheres (classes) to generate.\nnum_points_per_class: Number of points per class.\nnoise: Maximal noise applied for each point.\n\nReturns\n\nA tuple of (normalized_points, labels), where normalized_points is a matrix of 3D points, and labels indicates class membership.\n\nExample\n\npoints, labels = make_blobs(5, 500, 0.5)\n\n\n\n\n\n","category":"function"},{"location":"#SpectralClusteringTools.make_lines","page":"Home","title":"SpectralClusteringTools.make_lines","text":"make_lines(num_classes::Int, num_points_per_class::Int, noise::Float64=0.0)\n\nGenerates a dataset of points distributed following straight lines. Each line corresponds to a class.\n\nArguments\n\nnum_classes: Number of lines (classes) to generate.\nnum_points_per_class: Number of points per class.\nnoise: Maximal noise applied for each point.\n\nReturns\n\nA tuple of (normalized_points, labels), where normalized_points is a matrix of 3D points, and labels indicates class membership.\n\nExample\n\npoints, labels = make_lines(5, 500, 0.3)\n\n\n\n\n\n","category":"function"},{"location":"#SpectralClusteringTools.make_spheres","page":"Home","title":"SpectralClusteringTools.make_spheres","text":"make_spheres(num_classes::Int, num_points_per_class::Int, noise::Float64=0.0, adjust_scale::Bool=true)\n\nGenerates a dataset of points distributed on the surfaces of spheres.  Each sphere corresponds to a class, and points are normalized.\n\nArguments\n\nnum_classes: Number of spheres (classes) to generate.\nnum_points_per_class: Number of points per class.\nnoise: Maximal noise applied for each point.\nadjust_scale: Adjusts the number of points.\n\nReturns\n\nA tuple of (normalized_points, labels), where normalized_points is a matrix of 3D points, and labels indicates class membership.\n\nExample\n\npoints, labels = make_sphere(3, 1000, 0.1, false)\n\n\n\n\n\n","category":"function"},{"location":"#SpectralClusteringTools.make_spirals","page":"Home","title":"SpectralClusteringTools.make_spirals","text":"make_spirals(num_points_per_class::Int, noise::Float64=0.0)\n\nGenerates a dataset of points following 2 interlacing spirals. Each spiral corresponds to a class.\n\nArguments\n\nnum_points_per_class: Number of points per class.\nnoise: Maximal noise applied for each point.\n\nReturns\n\nA tuple of (normalized_points, labels), where normalized_points is a matrix of 3D points, and labels indicates class membership.\n\nExample\n\npoints, labels = make_spirals(500, 1.0)\n\n\n\n\n\n","category":"function"},{"location":"#SpectralClusteringTools.recover_rotation-Tuple{Matrix{Float64}}","page":"Home","title":"SpectralClusteringTools.recover_rotation","text":"recoverrotation(X::Matrix{Float64}; maxiter::Int=2000, tol::Float64=1e-6, α::Float64=0.1)\n\nRecover the optimal rotation matrix R that best aligns the columns of the input matrix X with the canonical coordinate system.\n\nThis function uses an incremental gradient descent scheme based on Givens rotations to minimize the cost function and find the optimal rotation matrix.\n\nParameters:\n\nX::Matrix{Float64}: The input matrix of eigenvectors to be aligned.\nmax_iter::Int=2000: The maximum number of iterations for the gradient descent algorithm.\ntol::Float64=1e-6: The tolerance for convergence of the gradient descent algorithm.\nα::Float64=0.1: The learning rate for the gradient descent algorithm.\n\nReturns:\n\nR::Matrix{Float64}: The optimal rotation matrix.\nZ::Matrix{Float64}: The input matrix X rotated by the optimal rotation matrix R.\ncost::Float64: The final cost value of the optimization.\n\n\n\n\n\n","category":"method"}]
}
